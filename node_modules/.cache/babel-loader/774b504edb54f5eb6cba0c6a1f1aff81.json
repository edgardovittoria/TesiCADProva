{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Vector3 } from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\n\nconst _A = new Vector3();\n\nconst _B = new Vector3();\n\nconst _C = new Vector3();\n\nclass EdgeSplitModifier {\n  modify(geometry, cutOffAngle, tryKeepNormals = true) {\n    function computeNormals() {\n      normals = new Float32Array(indexes.length * 3);\n\n      for (let i = 0; i < indexes.length; i += 3) {\n        let index = indexes[i];\n\n        _A.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n\n        index = indexes[i + 1];\n\n        _B.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n\n        index = indexes[i + 2];\n\n        _C.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n\n        _C.sub(_B);\n\n        _A.sub(_B);\n\n        const normal = _C.cross(_A).normalize();\n\n        for (let j = 0; j < 3; j++) {\n          normals[3 * (i + j)] = normal.x;\n          normals[3 * (i + j) + 1] = normal.y;\n          normals[3 * (i + j) + 2] = normal.z;\n        }\n      }\n    }\n\n    function mapPositionsToIndexes() {\n      pointToIndexMap = Array(positions.length / 3);\n\n      for (let i = 0; i < indexes.length; i++) {\n        const index = indexes[i];\n\n        if (pointToIndexMap[index] == null) {\n          pointToIndexMap[index] = [];\n        }\n\n        pointToIndexMap[index].push(i);\n      }\n    }\n\n    function edgeSplitToGroups(indexes, cutOff, firstIndex) {\n      _A.set(normals[3 * firstIndex], normals[3 * firstIndex + 1], normals[3 * firstIndex + 2]).normalize();\n\n      const result = {\n        splitGroup: [],\n        currentGroup: [firstIndex]\n      };\n\n      for (const j of indexes) {\n        if (j !== firstIndex) {\n          _B.set(normals[3 * j], normals[3 * j + 1], normals[3 * j + 2]).normalize();\n\n          if (_B.dot(_A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n\n      return result;\n    }\n\n    function edgeSplit(indexes, cutOff, original = null) {\n      if (indexes.length === 0) return;\n      const groupResults = [];\n\n      for (const index of indexes) {\n        groupResults.push(edgeSplitToGroups(indexes, cutOff, index));\n      }\n\n      let result = groupResults[0];\n\n      for (const groupResult of groupResults) {\n        if (groupResult.currentGroup.length > result.currentGroup.length) {\n          result = groupResult;\n        }\n      }\n\n      if (original != null) {\n        splitIndexes.push({\n          original: original,\n          indexes: result.currentGroup\n        });\n      }\n\n      if (result.splitGroup.length) {\n        edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n      }\n    }\n\n    if (geometry.isGeometry === true) {\n      console.error('THREE.EdgeSplitModifier no longer supports THREE.Geometry. Use BufferGeometry instead.');\n      return;\n    }\n\n    let hadNormals = false;\n    let oldNormals = null;\n\n    if (geometry.attributes.normal) {\n      hadNormals = true;\n      geometry = geometry.clone();\n\n      if (tryKeepNormals === true && geometry.index !== null) {\n        oldNormals = geometry.attributes.normal.array;\n      }\n\n      geometry.deleteAttribute('normal');\n    }\n\n    if (geometry.index == null) {\n      if (BufferGeometryUtils === undefined) {\n        throw 'THREE.EdgeSplitModifier relies on BufferGeometryUtils';\n      }\n\n      geometry = BufferGeometryUtils.mergeVertices(geometry);\n    }\n\n    const indexes = geometry.index.array;\n    const positions = geometry.getAttribute('position').array;\n    let normals;\n    let pointToIndexMap;\n    computeNormals();\n    mapPositionsToIndexes();\n    const splitIndexes = [];\n\n    for (const vertexIndexes of pointToIndexMap) {\n      edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 0.001);\n    }\n\n    const newAttributes = {};\n\n    for (const name of Object.keys(geometry.attributes)) {\n      const oldAttribute = geometry.attributes[name];\n      const newArray = new oldAttribute.array.constructor((indexes.length + splitIndexes.length) * oldAttribute.itemSize);\n      newArray.set(oldAttribute.array);\n      newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n    }\n\n    const newIndexes = new Uint32Array(indexes.length);\n    newIndexes.set(indexes);\n\n    for (let i = 0; i < splitIndexes.length; i++) {\n      const split = splitIndexes[i];\n      const index = indexes[split.original];\n\n      for (const attribute of Object.values(newAttributes)) {\n        for (let j = 0; j < attribute.itemSize; j++) {\n          attribute.array[(indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n        }\n      }\n\n      for (const j of split.indexes) {\n        newIndexes[j] = indexes.length + i;\n      }\n    }\n\n    geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(newIndexes, 1));\n\n    for (const name of Object.keys(newAttributes)) {\n      geometry.setAttribute(name, newAttributes[name]);\n    }\n\n    if (hadNormals) {\n      geometry.computeVertexNormals();\n\n      if (oldNormals !== null) {\n        const changedNormals = new Array(oldNormals.length / 3).fill(false);\n\n        for (const splitData of splitIndexes) changedNormals[splitData.original] = true;\n\n        for (let i = 0; i < changedNormals.length; i++) {\n          if (changedNormals[i] === false) {\n            for (let j = 0; j < 3; j++) geometry.attributes.normal.array[3 * i + j] = oldNormals[3 * i + j];\n          }\n        }\n      }\n    }\n\n    return geometry;\n  }\n\n}\n\nexport { EdgeSplitModifier };","map":{"version":3,"sources":["/home/edgardo/WebstormProjects/prova-react-three-fiber/node_modules/three/examples/jsm/modifiers/EdgeSplitModifier.js"],"names":["BufferAttribute","BufferGeometry","Vector3","BufferGeometryUtils","_A","_B","_C","EdgeSplitModifier","modify","geometry","cutOffAngle","tryKeepNormals","computeNormals","normals","Float32Array","indexes","length","i","index","set","positions","sub","normal","cross","normalize","j","x","y","z","mapPositionsToIndexes","pointToIndexMap","Array","push","edgeSplitToGroups","cutOff","firstIndex","result","splitGroup","currentGroup","dot","edgeSplit","original","groupResults","groupResult","splitIndexes","isGeometry","console","error","hadNormals","oldNormals","attributes","clone","array","deleteAttribute","undefined","mergeVertices","getAttribute","vertexIndexes","Math","cos","newAttributes","name","Object","keys","oldAttribute","newArray","constructor","itemSize","normalized","newIndexes","Uint32Array","split","attribute","values","setIndex","setAttribute","computeVertexNormals","changedNormals","fill","splitData"],"mappings":"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","sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tVector3\n} from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\n\nconst _A = new Vector3();\nconst _B = new Vector3();\nconst _C = new Vector3();\n\nclass EdgeSplitModifier {\n\n\tmodify( geometry, cutOffAngle, tryKeepNormals = true ) {\n\n\t\tfunction computeNormals() {\n\n\t\t\tnormals = new Float32Array( indexes.length * 3 );\n\n\t\t\tfor ( let i = 0; i < indexes.length; i += 3 ) {\n\n\t\t\t\tlet index = indexes[ i ];\n\n\t\t\t\t_A.set(\n\t\t\t\t\tpositions[ 3 * index ],\n\t\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\t\tindex = indexes[ i + 1 ];\n\t\t\t\t_B.set(\n\t\t\t\t\tpositions[ 3 * index ],\n\t\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\t\tindex = indexes[ i + 2 ];\n\t\t\t\t_C.set(\n\t\t\t\t\tpositions[ 3 * index ],\n\t\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\t\t_C.sub( _B );\n\t\t\t\t_A.sub( _B );\n\n\t\t\t\tconst normal = _C.cross( _A ).normalize();\n\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tnormals[ 3 * ( i + j ) ] = normal.x;\n\t\t\t\t\tnormals[ 3 * ( i + j ) + 1 ] = normal.y;\n\t\t\t\t\tnormals[ 3 * ( i + j ) + 2 ] = normal.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction mapPositionsToIndexes() {\n\n\t\t\tpointToIndexMap = Array( positions.length / 3 );\n\n\t\t\tfor ( let i = 0; i < indexes.length; i ++ ) {\n\n\t\t\t\tconst index = indexes[ i ];\n\n\t\t\t\tif ( pointToIndexMap[ index ] == null ) {\n\n\t\t\t\t\tpointToIndexMap[ index ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tpointToIndexMap[ index ].push( i );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction edgeSplitToGroups( indexes, cutOff, firstIndex ) {\n\n\t\t\t_A.set( normals[ 3 * firstIndex ], normals[ 3 * firstIndex + 1 ], normals[ 3 * firstIndex + 2 ] ).normalize();\n\n\t\t\tconst result = {\n\t\t\t\tsplitGroup: [],\n\t\t\t\tcurrentGroup: [ firstIndex ]\n\t\t\t};\n\n\t\t\tfor ( const j of indexes ) {\n\n\t\t\t\tif ( j !== firstIndex ) {\n\n\t\t\t\t\t_B.set( normals[ 3 * j ], normals[ 3 * j + 1 ], normals[ 3 * j + 2 ] ).normalize();\n\n\t\t\t\t\tif ( _B.dot( _A ) < cutOff ) {\n\n\t\t\t\t\t\tresult.splitGroup.push( j );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult.currentGroup.push( j );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\n\t\tfunction edgeSplit( indexes, cutOff, original = null ) {\n\n\t\t\tif ( indexes.length === 0 ) return;\n\n\t\t\tconst groupResults = [];\n\n\t\t\tfor ( const index of indexes ) {\n\n\t\t\t\tgroupResults.push( edgeSplitToGroups( indexes, cutOff, index ) );\n\n\t\t\t}\n\n\t\t\tlet result = groupResults[ 0 ];\n\n\t\t\tfor ( const groupResult of groupResults ) {\n\n\t\t\t\tif ( groupResult.currentGroup.length > result.currentGroup.length ) {\n\n\t\t\t\t\tresult = groupResult;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif ( original != null ) {\n\n\t\t\t\tsplitIndexes.push( {\n\t\t\t\t\toriginal: original,\n\t\t\t\t\tindexes: result.currentGroup\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( result.splitGroup.length ) {\n\n\t\t\t\tedgeSplit( result.splitGroup, cutOff, original || result.currentGroup[ 0 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\tconsole.error( 'THREE.EdgeSplitModifier no longer supports THREE.Geometry. Use BufferGeometry instead.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet hadNormals = false;\n\t\tlet oldNormals = null;\n\n\t\tif ( geometry.attributes.normal ) {\n\n\t\t\thadNormals = true;\n\n\t\t\tgeometry = geometry.clone();\n\n\t\t\tif ( tryKeepNormals === true && geometry.index !== null ) {\n\n\t\t\t\toldNormals = geometry.attributes.normal.array;\n\n\t\t\t}\n\n\t\t\tgeometry.deleteAttribute( 'normal' );\n\n\t\t}\n\n\t\tif ( geometry.index == null ) {\n\n\t\t\tif ( BufferGeometryUtils === undefined ) {\n\n\t\t\t\tthrow 'THREE.EdgeSplitModifier relies on BufferGeometryUtils';\n\n\t\t\t}\n\n\t\t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\n\t\t}\n\n\t\tconst indexes = geometry.index.array;\n\t\tconst positions = geometry.getAttribute( 'position' ).array;\n\n\t\tlet normals;\n\t\tlet pointToIndexMap;\n\n\t\tcomputeNormals();\n\t\tmapPositionsToIndexes();\n\n\t\tconst splitIndexes = [];\n\n\t\tfor ( const vertexIndexes of pointToIndexMap ) {\n\n\t\t\tedgeSplit( vertexIndexes, Math.cos( cutOffAngle ) - 0.001 );\n\n\t\t}\n\n\t\tconst newAttributes = {};\n\t\tfor ( const name of Object.keys( geometry.attributes ) ) {\n\n\t\t\tconst oldAttribute = geometry.attributes[ name ];\n\t\t\tconst newArray = new oldAttribute.array.constructor( ( indexes.length + splitIndexes.length ) * oldAttribute.itemSize );\n\t\t\tnewArray.set( oldAttribute.array );\n\t\t\tnewAttributes[ name ] = new BufferAttribute( newArray, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t}\n\n\t\tconst newIndexes = new Uint32Array( indexes.length );\n\t\tnewIndexes.set( indexes );\n\n\t\tfor ( let i = 0; i < splitIndexes.length; i ++ ) {\n\n\t\t\tconst split = splitIndexes[ i ];\n\t\t\tconst index = indexes[ split.original ];\n\n\t\t\tfor ( const attribute of Object.values( newAttributes ) ) {\n\n\t\t\t\tfor ( let j = 0; j < attribute.itemSize; j ++ ) {\n\n\t\t\t\t\tattribute.array[ ( indexes.length + i ) * attribute.itemSize + j ] =\n\t\t\t\t\t\tattribute.array[ index * attribute.itemSize + j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( const j of split.indexes ) {\n\n\t\t\t\tnewIndexes[ j ] = indexes.length + i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( newIndexes, 1 ) );\n\n\t\tfor ( const name of Object.keys( newAttributes ) ) {\n\n\t\t\tgeometry.setAttribute( name, newAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( hadNormals ) {\n\n\t\t\tgeometry.computeVertexNormals();\n\n\t\t\tif ( oldNormals !== null ) {\n\n\t\t\t\tconst changedNormals = new Array( oldNormals.length / 3 ).fill( false );\n\n\t\t\t\tfor ( const splitData of splitIndexes )\n\t\t\t\t\tchangedNormals[ splitData.original ] = true;\n\n\t\t\t\tfor ( let i = 0; i < changedNormals.length; i ++ ) {\n\n\t\t\t\t\tif ( changedNormals[ i ] === false ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ )\n\t\t\t\t\t\t\tgeometry.attributes.normal.array[ 3 * i + j ] = oldNormals[ 3 * i + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n}\n\n\n\nexport { EdgeSplitModifier };\n"]},"metadata":{},"sourceType":"module"}